;TESTS PAS TESTéS

;(COMP '(defun fibonacci (n) (if (<= n 2) 1 (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))
;(LITOASM '(:CALL + (:CONST 1) (:CONST 2)) ())
;(COMP '(defun factorielle (n) (if (<= n 0) 1 (* n (factorielle (- n 1))))))
;(COMP '(cond ((< 0 1) 0) ((> 0 1) 1)))
;(COMP '(defun  progn_de_factorielle (n) (progn (+ 1 2) (+ 2 3) (+ 3 4) (+ 4 n))))

;(VMEVAL 'vm '(defun loop_test (li n) (loop for cel in li do (atom cel))))
;(COMP '(defun loop_test (li n) (loop for cel in li do (atom cel))))
;(LISPTOLI '(defun loop_test (li n) (loop for cel in li do (atom cel))) ())

;On n'a pas le let donc ça ne marchera pas, logiquement
;(LISPTOLI '(defun test_let (x y z) (let ((a 5) (b 10)) (+ a x) (+ y b))) ())
;(COMP '(defun test_let (x y z) (let ((a 5) (b 10)) (+ a x) (+ y b))))
;(VMEVAL 'vm '(defun test_let (x y z) (let ((a 5) (b 10)) (+ a x y b))))

(defun COMP (expr) 
	(print 
		(LISPTOLI 
			expr 
			()
		)
	) 
	(LITOASM 
		(LISPTOLI 
			expr 
			()
		) 
		()
	)
)

(defun LITOASM (expr env) 
	(if 
		(numberp 
			(first 
				expr
			)
		)
		(let 
			(
				(name 
					(second 
						expr
					)
				) 
				(args 
					(third 
						expr
					)
				)
			)
			(append
				(list 
					(list 
						:label 
						name
					) 
					(list 
						:stack 
						(first 
							expr
						)
					)
				)
				(LITOASM 
					args 
					env
				)
				(list 
					(list 
						:rtn
					)
				)
			)
		)
		(case 
			(first 
				expr
			)
			(:if
				(append
					(LITOASM 
						(second 
							expr
						) 
						env
					)
					(list 
						(list 
							:skipnil 
							(+ 
								1 
								(length 
									(LITOASM 
										(copy-list 
											(third 
												expr
											)
										) 
										env
									)
								)
							)
						)
					)
					(LITOASM 
						(third 
							expr
						) 
						env
					)
					(list 
						(list 
							:rtn
						)
					)
					(LITOASM 
						(fourth 
							expr
						) 
						env
					)
				)
			)
			(:call
				(let 
					(ll 
						(length 
							(third 
								expr
							)
						)
					)
					(if 
						(= 
							ll 
							0
						)
						(list 
							(list 
								:call 
								(second 
									expr
								)
							)
						)
						(if 
							(= 
								ll 
								1
							)
							(append
								(MAPLITOASM 
									(third 
										expr
									) 
									env
								)
								(list 
									(list 
										:call 
										(second 
											expr
										)
									)
								)
							)
							(append 
								(MAPLITOASM 
									(third 
										expr
									) 
									env
								)
								(CALLTOASM 
									(second 
										expr
									) 
									ll
								)
							)
						)
					)
				)
			)
			(:mcall
				(append
					(MAPLITOASM 
						(third 
							expr
						) 
						env
					)
					(list 
						(list 
							:call 
							(second 
								expr
							)
						)
					)
				)
			)
			(:const 
				(list 
					(list 
						:const 
						(second 
							expr
						)
					)
				)
			)
			(:var 
				(list 
					(list 
						:var 
						(second 
							expr
						)
					)
				)
			)
			(:progn 
				(MAPLITOASM 
					(first 
						(rest 
							expr
						)
					) 
					env
				)
			)
			(:loop
				(append
					(list 
						(list 
							:label 
							(third 
								expr
							)
						)
					)
					(LITOASM 
						(second 
							expr
						) 
						env
					)
					(list 
						(list 
							:call 
							'car
						)
					)
					(list 
						(list 
							:call 
							'atom
						)
					)
					(list 
						(list 
							:skiptrue 
							(+ 
								1 
								(length 
									(LITOASM 
										(copy-list 
											(fourth 
												expr
											)
										) 
										env
									)
								)
							)
						)
					)
					(LITOASM 
						(fourth 
							expr
						) 
						env
					)
					(LITOASM 
						(fifth 
							expr
						) 
						env
					)
					(list 
						(list 
							:jump 
							(third 
								expr
							)
						)
					)
				)
			)
			(:setf 
				NIL
			)
			(:set-var 
				(append
					(LITOASM 
						(third 
							expr
						) 
						env
					)
					(list 
						(list 
							:set-var 
							(second 
								(second 
									expr
								)
							)
						)
					)
				)
			)
			(:let-var 
				(append
					(LITOASM 
						(third 
							expr
						) 
						env
					)
					(list 
						(list 
							:store
						)
					)
				)
			)
			(:let 
				(append
					(MAPLITOASM 
						(third 
							expr
						) 
						()
					)
					(MAPLITOASM 
						(fourth 
							expr
						) 
						()
					)
				)
			)
			(:unknown 
				(let 
					(expr2 
						(LISPTOLI 
							(second 
								expr
							) 
							(third 
								expr
							)
						)
					)          
					(LITOASM 
						expr2 
						env
					)
				)
			)
		)
	)
)


(defun CALLTOASM (expr n) 
	(if 
		(<= 
			n 
			1
		)
		NIL 
		(cons 
			(list 
				:call 
				expr
			) 
			(CALLTOASM 
				expr 
				(- 
					n 
					1
				)
			)
		)
	)
)

(defun MAPLITOASM (lcode env) 
	(if 
		(atom 
			lcode
		)
		NIL 
		(append 
			(LITOASM 
				(first 
					lcode
				) 
				env
			)
			(MAPLITOASM 
				(cdr 
					lcode
				) 
				env
			)
		)
	)
)
	   
;SOUS FORME LINEAIRE

(defun COMP (expr) (print (LISPTOLI expr ())) (LITOASM (LISPTOLI expr ()) ()))
(defun LITOASM (expr env) (if (numberp (first expr)) (let ((name (second expr)) (args (third expr))) (append (list (list :label name) (list :stack (first expr))) (LITOASM args env) (list (list :rtn)))) (case (first expr) (:if (append (LITOASM (second expr) env) (list (list :skipnil (+ 1 (length (LITOASM (copy-list (third expr)) env))))) (LITOASM (third expr) env) (list (list :rtn)) (LITOASM (fourth expr) env))) (:call (let (ll (length (third expr))) (if (= ll 0) (list (list :call (second expr))) (if (= ll 1) (append (MAPLITOASM (third expr) env) (list (list :call (second expr)))) (append (MAPLITOASM (third expr) env) (CALLTOASM (second expr) ll)))))) (:mcall (append (MAPLITOASM (third expr) env) (list (list :call (second expr))))) (:const (list (list :const (second expr)))) (:var (list (list :var (second expr)))) (:progn (MAPLITOASM (first (rest expr)) env)) (:loop (append (list (list :label (third expr))) (LITOASM (second expr) env) (list (list :call 'car)) (list (list :call 'atom)) (list (list :skiptrue (+ 1 (length (LITOASM (copy-list (fourth expr)) env))))) (LITOASM (fourth expr) env) (LITOASM (fifth expr) env) (list (list :jump (third expr))))) (:setf NIL) (:set-var (append (LITOASM (third expr) env) (list (list :set-var (second (second expr)))))) (:let-var (append (LITOASM (third expr) env) (list (list :store)))) (:let (append (MAPLITOASM (third expr) ()) (MAPLITOASM (fourth expr) ()))) (:unknown (let (expr2 (LISPTOLI (second expr) (third expr))) (LITOASM expr2 env))))))
(defun CALLTOASM (expr n) (if (<= n 1) NIL (cons (list :call expr) (CALLTOASM expr (- n 1)))))
(defun MAPLITOASM (lcode env) (if (atom lcode) NIL (append (LITOASM (first lcode) env) (MAPLITOASM (cdr lcode) env))))